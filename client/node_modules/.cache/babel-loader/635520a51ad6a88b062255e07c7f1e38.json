{"ast":null,"code":"var xtend = require('xtend');\n\nfunction parseCookie(auth, cookieHeader) {\n  var cookieParser = auth.cookieParser(auth.secret);\n  var req = {\n    headers: {\n      cookie: cookieHeader\n    }\n  };\n  var result;\n  cookieParser(req, {}, function (err) {\n    if (err) throw err;\n    result = req.signedCookies || req.cookies;\n  });\n  return result;\n}\n\nfunction authorize(options) {\n  var defaults = {\n    key: 'connect.sid',\n    secret: null,\n    store: null,\n    userProperty: 'user',\n    success: function (data, accept) {\n      if (data.socketio_version_1) {\n        accept();\n      } else {\n        accept(null, true);\n      }\n    },\n    fail: function (data, message, critical, accept) {\n      if (data.socketio_version_1) {\n        accept(new Error(message));\n      } else {\n        accept(null, false);\n      }\n    }\n  };\n  var auth = xtend(defaults, options);\n\n  if (!auth.passport) {\n    try {\n      auth.passport = require('passport');\n    } catch (err) {\n      throw new Error('passport is required to use require(\\'passport\\'), please install passport');\n    }\n  }\n\n  if (!auth.cookieParser) {\n    try {\n      auth.cookieParser = require('cookie-parser');\n    } catch (err) {\n      throw new Error('cookieParser is required use require(\\'cookie-parser\\'), connect.cookieParser or express.cookieParser');\n    }\n  }\n\n  return function (data, accept) {\n    // socket.io v1.0 now provides socket handshake data via `socket.request`\n    if (data.request) {\n      data = data.request;\n      data.socketio_version_1 = true;\n    }\n\n    data.cookie = parseCookie(auth, data.headers.cookie || '');\n    data.sessionID = data.query && data.query.session_id || data._query && data._query.session_id || data.cookie[auth.key] || '';\n    data[auth.userProperty] = {\n      logged_in: false\n    };\n    if (data.xdomain && !data.sessionID) return auth.fail(data, 'Can not read cookies from CORS-Requests. See CORS-Workaround in the readme.', false, accept);\n    auth.store.get(data.sessionID, function (err, session) {\n      if (err) return auth.fail(data, 'Error in session store:\\n' + err.message, true, accept);\n      if (!session) return auth.fail(data, 'No session found', false, accept);\n      if (!session[auth.passport._key]) return auth.fail(data, 'Passport was not initialized', true, accept);\n      var userKey = session[auth.passport._key].user;\n      if (typeof userKey === 'undefined') return auth.fail(data, 'User not authorized through passport. (User Property not found)', false, accept);\n      auth.passport.deserializeUser(userKey, data, function (err, user) {\n        if (err) return auth.fail(data, err, true, accept);\n        if (!user) return auth.fail(data, \"User not found\", false, accept);\n        data[auth.userProperty] = user;\n        data[auth.userProperty].logged_in = true;\n        auth.success(data, accept);\n      });\n    });\n  };\n}\n\nfunction filterSocketsByUser(socketIo, filter) {\n  var handshaken = [];\n\n  for (var i in socketIo.sockets.connected) if (socketIo.sockets.connected[i].handshake) handshaken.push(socketIo.sockets.connected[i]);\n\n  return Object.keys(handshaken || {}).filter(function (skey) {\n    return filter(handshaken[skey].conn.request.user);\n  }).map(function (skey) {\n    return handshaken[skey];\n  });\n}\n\nexports.authorize = authorize;\nexports.filterSocketsByUser = filterSocketsByUser;","map":{"version":3,"sources":["C:/Users/noogler/Documents/tutorgenic/dev/node_modules/passport.socketio/lib/index.js"],"names":["xtend","require","parseCookie","auth","cookieHeader","cookieParser","secret","req","headers","cookie","result","err","signedCookies","cookies","authorize","options","defaults","key","store","userProperty","success","data","accept","socketio_version_1","fail","message","critical","Error","passport","request","sessionID","query","session_id","_query","logged_in","xdomain","get","session","_key","userKey","user","deserializeUser","filterSocketsByUser","socketIo","filter","handshaken","i","sockets","connected","handshake","push","Object","keys","skey","conn","map","exports"],"mappings":"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","sourcesContent":["var xtend = require('xtend');\n\nfunction parseCookie(auth, cookieHeader) {\n  var cookieParser = auth.cookieParser(auth.secret);\n  var req = {\n    headers:{\n      cookie: cookieHeader\n    }\n  };\n  var result;\n  cookieParser(req, {}, function (err) {\n    if (err) throw err;\n    result = req.signedCookies || req.cookies;\n  });\n  return result;\n}\n\nfunction authorize(options) {\n  var defaults = {\n    key:          'connect.sid',\n    secret:       null,\n    store:        null,\n    userProperty: 'user',\n    success:      function (data, accept){\n      if (data.socketio_version_1) {\n        accept();\n      } else {\n        accept(null, true);\n      }\n    },\n    fail:         function (data, message, critical, accept) {\n      if (data.socketio_version_1) {\n        accept(new Error(message));\n      } else {\n        accept(null, false);\n      }\n    }\n  };\n\n  var auth = xtend(defaults, options);\n  \n  if(!auth.passport) {\n    try {\n      auth.passport = require('passport');\n    } catch (err) {\n      throw new Error('passport is required to use require(\\'passport\\'), please install passport');\n    }\n  }\n\n  if (!auth.cookieParser) {\n    try {\n      auth.cookieParser = require('cookie-parser');\n    } catch (err) {\n      throw new Error('cookieParser is required use require(\\'cookie-parser\\'), connect.cookieParser or express.cookieParser');\n    }\n  }\n\n  return function(data, accept){\n\n    // socket.io v1.0 now provides socket handshake data via `socket.request`\n    if (data.request) {\n      data = data.request;\n      data.socketio_version_1 = true;\n    }\n\n    data.cookie = parseCookie(auth, data.headers.cookie || '');\n    data.sessionID = (data.query && data.query.session_id) || (data._query && data._query.session_id) || data.cookie[auth.key] || '';\n    data[auth.userProperty] = {\n      logged_in: false\n    };\n\n    if(data.xdomain && !data.sessionID)\n      return auth.fail(data, 'Can not read cookies from CORS-Requests. See CORS-Workaround in the readme.', false, accept);\n\n    auth.store.get(data.sessionID, function(err, session){\n      if(err)\n        return auth.fail(data, 'Error in session store:\\n' + err.message, true, accept);\n      if(!session)\n        return auth.fail(data, 'No session found', false, accept);\n      if(!session[auth.passport._key])\n        return auth.fail(data, 'Passport was not initialized', true, accept);\n\n      var userKey = session[auth.passport._key].user;\n\n      if(typeof(userKey) === 'undefined')\n        return auth.fail(data, 'User not authorized through passport. (User Property not found)', false, accept);\n\n      auth.passport.deserializeUser(userKey, data, function(err, user) {\n        if (err)\n          return auth.fail(data, err, true, accept);\n        if (!user)\n          return auth.fail(data, \"User not found\", false, accept);\n        data[auth.userProperty] = user;\n        data[auth.userProperty].logged_in = true;\n        auth.success(data, accept);\n      });\n\n    });\n  };\n}\n\nfunction filterSocketsByUser(socketIo, filter){\n  var handshaken = [];\n  for ( var i in socketIo.sockets.connected )\n    if ( socketIo.sockets.connected[i].handshake )\n        handshaken.push( socketIo.sockets.connected[i] )\n\n  return Object.keys(handshaken || {})\n    .filter(function(skey){\n      return filter(handshaken[skey].conn.request.user);\n    })\n    .map(function(skey){\n      return handshaken[skey];\n    });\n}\n\nexports.authorize = authorize;\nexports.filterSocketsByUser = filterSocketsByUser;\n"]},"metadata":{},"sourceType":"script"}